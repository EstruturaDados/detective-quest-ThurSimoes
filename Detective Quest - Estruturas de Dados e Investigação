#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 10 // Define o tamanho da nossa Tabela Hash

// --- ESTRUTURAS DE DADOS ---

// Estrutura para os cômodos da mansão (Árvore Binária)
typedef struct Sala {
    char nome[50];
    const char* pista;
    struct Sala* esquerda;
    struct Sala* direita;
} Sala;

// Estrutura para as pistas coletadas (Árvore Binária de Busca - BST)
typedef struct PistaNode {
    char pista[150];
    struct PistaNode* esquerda;
    struct PistaNode* direita;
} PistaNode;

// Estrutura para a associação Pista -> Suspeito (Tabela Hash com Encadeamento)
typedef struct HashNode {
    char pista[150];
    char suspeito[50];
    struct HashNode* proximo;
} HashNode;

// --- PROTÓTIPOS DAS FUNÇÕES ---
// Funções da Tabela Hash
unsigned int hash(const char* chave);
void inserirNaHash(HashNode** tabela, const char* pista, const char* suspeito);
const char* encontrarSuspeito(HashNode** tabela, const char* pista);

// Funções do Jogo e das Árvores
Sala* criarSala(const char* nome, const char* pista);
PistaNode* inserirPista(PistaNode* raiz, const char* pista);
void exibirPistas(PistaNode* raiz);
int contarPistasParaSuspeito(PistaNode* raizPistas, HashNode** tabelaHash, const char* suspeito);
void verificarSuspeitoFinal(PistaNode* raizPistas, HashNode** tabelaHash);
void explorarSalas(Sala* salaInicial);

// Funções de Gerenciamento de Memória
void liberarMapa(Sala* no);
void liberarPistas(PistaNode* raiz);
void liberarTabelaHash(HashNode** tabela);


// --- FUNÇÃO PRINCIPAL ---
int main() {
    // 1. Criação do mapa da mansão com suas respectivas pistas
    Sala* hall = criarSala("Hall de Entrada", "A porta principal foi arrombada por uma ferramenta pesada.");
    Sala* salaDeEstar = criarSala("Sala de Estar", "Um recibo de uma loja de ferramentas foi encontrado.");
    Sala* salaDeJantar = criarSala("Sala de Jantar", "Um guardanapo com uma anotação: 'O jardineiro sabe demais'.");
    Sala* biblioteca = criarSala("Biblioteca", "Um livro sobre venenos estava fora do lugar.");
    Sala* cozinha = criarSala("Cozinha", "Um frasco quebrado com um forte cheiro de produto químico.");
    Sala* jardim = criarSala("Jardim", "Pegadas de botas enlameadas foram vistas perto da janela.");
    Sala* escritorio = criarSala("Escritório Secreto", "Um bilhete ameaçador assinado por 'Mordomo'.");

    // Conexão das salas
    hall->esquerda = salaDeEstar;
    hall->direita = salaDeJantar;
    salaDeEstar->esquerda = biblioteca;
    salaDeEstar->direita = cozinha;
    salaDeJantar->direita = jardim;
    biblioteca->esquerda = escritorio;

    // 2. Inicia a exploração
    explorarSalas(hall);

    // 3. Libera a memória do mapa (as outras estruturas são liberadas em explorarSalas)
    liberarMapa(hall);
    printf("\nMemória da mansão liberada.\n");

    return 0;
}

// --- FUNÇÕES DA LÓGICA DO JOGO ---

/**
 * @brief Navega pela mansão, coleta pistas e inicia a fase de acusação.
 * @param salaInicial O ponto de partida da exploração (nó raiz do mapa).
 */
void explorarSalas(Sala* salaInicial) {
    // Inicializa as estruturas de dados
    PistaNode* raizPistas = NULL;
    HashNode* tabelaHash[TABLE_SIZE] = {NULL}; // Inicializa a tabela com NULL

    // Popula a tabela hash com a relação Pista -> Suspeito
    inserirNaHash(tabelaHash, "A porta principal foi arrombada por uma ferramenta pesada.", "Jardineiro");
    inserirNaHash(tabelaHash, "Um recibo de uma loja de ferramentas foi encontrado.", "Jardineiro");
    inserirNaHash(tabelaHash, "Um guardanapo com uma anotação: 'O jardineiro sabe demais'.", "Cozinheira");
    inserirNaHash(tabelaHash, "Um livro sobre venenos estava fora do lugar.", "Mordomo");
    inserirNaHash(tabelaHash, "Um frasco quebrado com um forte cheiro de produto químico.", "Cozinheira");
    inserirNaHash(tabelaHash, "Pegadas de botas enlameadas foram vistas perto da janela.", "Jardineiro");
    inserirNaHash(tabelaHash, "Um bilhete ameaçador assinado por 'Mordomo'.", "Mordomo");

    Sala* salaAtual = salaInicial;
    char escolha;

    printf("--- Detective Quest: O Desafio Mestre ---\n");
    printf("Explore, colete pistas, conecte-as a um suspeito e faça sua acusação!\n");

    while (1) {
        printf("\n------------------------------------------------\n");
        printf("Você está em: %s\n", salaAtual->nome);

        if (salaAtual->pista != NULL) {
            printf(">> Pista encontrada! \"%s\"\n", salaAtual->pista);
            raizPistas = inserirPista(raizPistas, salaAtual->pista);
            salaAtual->pista = NULL; // Marca como coletada
        }

        printf("Para onde você quer ir? (e/d/s): ");
        scanf(" %c", &escolha);

        if (escolha == 's' || escolha == 'S') {
            printf("\nVocê decidiu que tem pistas suficientes. Hora da acusação!\n");
            break; // Sai do loop para iniciar o julgamento
        } else if (escolha == 'e' || escolha == 'E') {
            if (salaAtual->esquerda != NULL) salaAtual = salaAtual->esquerda;
            else printf("Não há caminho por aqui.\n");
        } else if (escolha == 'd' || escolha == 'D') {
            if (salaAtual->direita != NULL) salaAtual = salaAtual->direita;
            else printf("Não há caminho por aqui.\n");
        } else {
            printf("Opção inválida.\n");
        }
    }

    // Inicia a fase final de verificação
    verificarSuspeitoFinal(raizPistas, tabelaHash);

    // Libera a memória das estruturas de dados restantes
    liberarPistas(raizPistas);
    liberarTabelaHash(tabelaHash);
    printf("Memória das pistas e dos suspeitos liberada.\n");
}

/**
 * @brief Conduz a fase final de julgamento.
 * @param raizPistas A raiz da BST de pistas coletadas.
 * @param tabelaHash A tabela hash de suspeitos.
 */
void verificarSuspeitoFinal(PistaNode* raizPistas, HashNode** tabelaHash) {
    char acusado[50];
    printf("\n========== FASE DE ACUSAÇÃO ==========\n");
    printf("Suspeitos: Mordomo, Jardineiro, Cozinheira\n");
    printf("\nPistas que você coletou:\n");
    if (raizPistas == NULL) {
        printf("  Nenhuma.\n");
    } else {
        exibirPistas(raizPistas);
    }
    
    printf("\nCom base nas evidências, quem você acusa? ");
    scanf("%s", acusado);

    int contagem = contarPistasParaSuspeito(raizPistas, tabelaHash, acusado);

    printf("\nAnalisando as evidências contra %s...\n", acusado);
    printf("... %d pista(s) apontam para este suspeito.\n\n", contagem);

    if (contagem >= 2) {
        printf("Veredito: CULPADO! As evidências são conclusivas. Você resolveu o caso!\n");
    } else {
        printf("Veredito: INOCENTE! As provas são insuficientes. O verdadeiro culpado escapou...\n");
    }
    printf("======================================\n");
}

/**
 * @brief Conta recursivamente quantas pistas na BST apontam para um suspeito.
 * @return O número de pistas que incriminam o suspeito.
 */
int contarPistasParaSuspeito(PistaNode* raizPistas, HashNode** tabelaHash, const char* suspeito) {
    if (raizPistas == NULL) {
        return 0; // Caso base: sem pistas, sem contagem
    }

    const char* suspeitoDaPista = encontrarSuspeito(tabelaHash, raizPistas->pista);
    int contagem = 0;

    // Se a pista atual aponta para o suspeito acusado, conta 1
    if (suspeitoDaPista != NULL && strcmp(suspeitoDaPista, suspeito) == 0) {
        contagem = 1;
    }

    // Soma a contagem das sub-árvores esquerda e direita
    return contagem + contarPistasParaSuspeito(raizPistas->esquerda, tabelaHash, suspeito) + contarPistasParaSuspeito(raizPistas->direita, tabelaHash, suspeito);
}

// --- FUNÇÕES DAS ESTRUTURAS DE DADOS ---

/**
 * @brief Função de hash simples para converter uma string em um índice.
 */
unsigned int hash(const char* chave) {
    unsigned long hash = 5381;
    int c;
    while ((c = *chave++))
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    return hash % TABLE_SIZE;
}

/**
 * @brief Insere uma associação pista/suspeito na Tabela Hash.
 */
void inserirNaHash(HashNode** tabela, const char* pista, const char* suspeito) {
    unsigned int indice = hash(pista);
    HashNode* novoNode = (HashNode*)malloc(sizeof(HashNode));
    strcpy(novoNode->pista, pista);
    strcpy(novoNode->suspeito, suspeito);
    novoNode->proximo = tabela[indice];
    tabela[indice] = novoNode;
}

/**
 * @brief Encontra um suspeito na Tabela Hash com base na pista.
 * @return O nome do suspeito ou NULL se não for encontrado.
 */
const char* encontrarSuspeito(HashNode** tabela, const char* pista) {
    unsigned int indice = hash(pista);
    HashNode* atual = tabela[indice];
    while (atual != NULL) {
        if (strcmp(atual->pista, pista) == 0) {
            return atual->suspeito;
        }
        atual = atual->proximo;
    }
    return NULL;
}

/**
 * @brief Insere uma nova pista na BST de forma ordenada.
 */
PistaNode* inserirPista(PistaNode* raiz, const char* pista) {
    if (raiz == NULL) {
        PistaNode* novoNode = (PistaNode*)malloc(sizeof(PistaNode));
        strcpy(novoNode->pista, pista);
        novoNode->esquerda = novoNode->direita = NULL;
        return novoNode;
    }
    if (strcmp(pista, raiz->pista) < 0) {
        raiz->esquerda = inserirPista(raiz->esquerda, pista);
    } else if (strcmp(pista, raiz->pista) > 0) {
        raiz->direita = inserirPista(raiz->direita, pista);
    }
    return raiz;
}

/**
 * @brief Exibe as pistas da BST em ordem alfabética (percurso em ordem).
 */
void exibirPistas(PistaNode* raiz) {
    if (raiz == NULL) return;
    exibirPistas(raiz->esquerda);
    printf("  - %s\n", raiz->pista);
    exibirPistas(raiz->direita);
}

/**
 * @brief Cria uma nova sala para o mapa.
 */
Sala* criarSala(const char* nome, const char* pista) {
    Sala* novaSala = (Sala*)malloc(sizeof(Sala));
    strcpy(novaSala->nome, nome);
    novaSala->pista = pista;
    novaSala->esquerda = novaSala->direita = NULL;
    return novaSala;
}


// --- FUNÇÕES DE GERENCIAMENTO DE MEMÓRIA ---
void liberarMapa(Sala* no) {
    if (no == NULL) return;
    liberarMapa(no->esquerda);
    liberarMapa(no->direita);
    free(no);
}

void liberarPistas(PistaNode* raiz) {
    if (raiz == NULL) return;
    liberarPistas(raiz->esquerda);
    liberarPistas(raiz->direita);
    free(raiz);
}

void liberarTabelaHash(HashNode** tabela) {
    for (int i = 0; i < TABLE_SIZE; i++) {
        HashNode* atual = tabela[i];
        while (atual != NULL) {
            HashNode* temp = atual;
            atual = atual->proximo;
            free(temp);
        }
    }
}
